#!/usr/bin/env python3

# pylint: disable=invalid-name

'''
Create a release using GitHub's API, and upload its assets
'''

import json
import sys
import os
import ntpath

from urllib.parse import urljoin

import requests

GITHUB_API = 'https://api.github.com'

def check_status(res, j):
    '''
    Check that the HTTP server didn't return an error
    '''
    if res.status_code >= 400:
        msg = j.get('message', 'UNDEFINED')
        print(f'ERROR: {msg} / code {res.status_code}')
        return 1
    return 0


# pylint: disable=redefined-outer-name
def check_release(owner, repo, tag, token):
    '''
    Check if the release already exists on GitHub
    '''
    url = urljoin(GITHUB_API, '/'.join(['repos', owner, repo, 'releases']))
    headers = {'Authorization': token}
    data = {'tag_name': tag, 'name': tag, 'body': f'winetricks - {tag}'}
    res = requests.post(url, auth=(owner, token), data=json.dumps(data), headers=headers)

    print("about to create release")
    j = json.loads(res.text)
    print(json.dumps(j, indent=4))
    if check_status(res, j):
        return 1
    return 0

# pylint: disable=redefined-outer-name
def create_release(owner, repo, tag, token):
    '''
    Create the release on GitHub
    '''
    url = urljoin(GITHUB_API, '/'.join(['repos', owner, repo, 'releases', 'tags', tag]))
    headers = {'Authorization': token}
    res = requests.post(url, auth=(owner, token), data=json.dumps(data), headers=headers)

    print("about to create release")
    j = json.loads(res.text)
    print(json.dumps(j, indent=4))
    if check_status(res, j):
        return 1
    return 0

# pylint: disable=too-many-locals,import-outside-toplevel
def upload_asset(path, owner, repo, tag):
    '''
    Upload the asset to github
    '''
    token = os.environ['GITHUB_TOKEN']

    url = urljoin(GITHUB_API,
                  '/'.join(['repos', owner, repo, 'releases', 'tags', tag]))
    res = requests.get(url)

    # FIXME: create_release is already a function, but still, this needs to be refactored
    # i.e., this belongs in main()

    print("uploading assets 1 (i.e., creating release)")
    j = json.loads(res.text)
    print(json.dumps(j, indent=4))
    if check_status(res, j):
        # release must not exist, creating release from tag
        # pylint: disable=no-else-return
        print("calling create release")
        if create_release(owner, repo, tag, token):
            return 0
        else:
            # Need to start over with uploading now that release is created
            # Return 1 to indicate we need to run upload_asset again
            return 1

    ### FIXME END

    upload_url = j['upload_url']
    upload_url = upload_url.split('{')[0]

    fname = ntpath.basename(path)
    with open(path, encoding="utf8") as f:
        contents = f.read()

    import mimetypes
    content = mimetypes.guess_type(path)
    content_type = content[0]
    print("content_type is {content_type}")

    headers = {'Content-Type': content_type, 'Authorization': token}
    params = {'name': fname}

    res = requests.post(upload_url, data=contents, auth=(owner, token),
                        headers=headers, params=params)

    # This is where it's returning 422 ^^

    print("uploading assets 2")
    j = json.loads(res.text)
    print(json.dumps(j, indent=4))
    if check_status(res, j):
        return 0
    print(f'SUCCESS: {fname} uploaded')
    return 0

if __name__ == '__main__':
    path = sys.argv[1]  # path of file to upload
    owner = sys.argv[2] # github account owner of the repo
    repo = sys.argv[3]  # github repo to upload to
    tag = sys.argv[4]   # tag to upload
    if not os.path.isabs(path):
        path = os.path.join(os.path.dirname(os.path.realpath(__file__)), path)
    
    # FIXME: refactor:
    #RET = 1  # Run upload_asset at least once.
    #while RET:
    #    RET = upload_asset(path, owner, repo, tag)

    # new flow:
    # step 1: make sure release doesn't already exist
    #         * if it does, error out/skip 
    #           (should probably warn/skip, since conceivably the script 
    #            could be called multiple times for multiple assets)
    # step 2: make a release
    # step 3: upload asset (.asc, which is generated by ./src/release.sh)

    check_release(path, owner, repo, tag)
